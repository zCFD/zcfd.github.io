<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Tutorial 3a: FWH Solver &#8212; zCFD User Guide v2024.04.8259-211-g4257f documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=7ede516a" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=659bf730" />
    <script src="../_static/documentation_options.js?v=2dfe7e2f"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="icon" href="../_static/fav.png"/>
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Running zCFD using EPIC" href="epic_tutorial.html" />
    <link rel="prev" title="Tutorial 4: Aero-acoustics" href="quick_start_4.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="tutorial-3a-fwh-solver">
<h1>Tutorial 3a: FWH Solver<a class="headerlink" href="#tutorial-3a-fwh-solver" title="Link to this heading">¶</a></h1>
<p>A <a class="reference internal" href="../fwh.html#fwh"><span class="std std-ref">Ffowcs-Williams Hawkings (FWH) solver</span></a>, which is used for prediction of farfield noise, is included in the zCFD distribution. In this section, we will use the zCFD FWH solver to calculate the sound experienced by two ‘observer microphones’ as a result of the aerodynamic noise generated by the flow around the cylinder.</p>
<p>In order to use an FWH solver to predict noise at observer microphones, we will first rerun the CFD simulation from <a class="reference internal" href="quick_start_3.html#tutorial-3"><span class="std std-ref">Tutorial 3</span></a> with some additional terms to record the flow variables on an ‘FWH surface’ in the near-field, noise generating region. We then use the FWH solver to propagate the noise from the near-field FWH surface to the observer microphones. For more detail on the FWH solver, see <a class="reference internal" href="../fwh.html#fwh"><span class="std std-ref">here</span></a>.</p>
<section id="running-zcfd-with-fwh-output">
<h2>Running zCFD with FWH output<a class="headerlink" href="#running-zcfd-with-fwh-output" title="Link to this heading">¶</a></h2>
<p>The flow we’re going to be running the FWH solver on is the shedding cylinder. To get the required inputs to our FWH solver, we need to define an <em>FWH surface</em>, and collect data on this surface during a CFD simulation.</p>
<p>The files required for the fwh tutorial can be downloaded <a class="reference external" href="https://zcfd.zenotech.com/tutorials/3/cylinder_fwh.zip" target="_blank">here</a>. In the zip file there’s a FWH surface definition file, called <em>fwh_surface1.stl</em>. Given we’ve already run the cylinder case in <a class="reference internal" href="quick_start_3.html#tutorial-3"><span class="std std-ref">Tutorial 3</span></a>, we can view the FWH surface in Paraview alongside the cylinder CFD volume data (see <a class="reference internal" href="quick_start_3.html#qs3-view-flowfield"><span class="std std-ref">here</span></a>), as below. You may find the surface easier to see if you set the <em>view style</em> to be <em>Feature Edges</em> instead of <em>Surface</em> for the FWH surface, and increase the <em>Line Width</em> in the <em>Geometry Representation</em>.</p>
<a class="reference internal image-reference" href="../_images/cylinder_fwh_surface1.png" id="qs3-stl-pic"><img alt="fwh_surface1.stl plotted alongside CFD volume solution" id="qs3-stl-pic" src="../_images/cylinder_fwh_surface1.png" style="width: 600px;" />
</a>
<p>The FWH surface encloses the noise generating near-field region, but does not intersect the wake, in order to avoid spurious pseudo-sound p[<a class="reference internal" href="#tutorial-3-citations"><span class="std std-ref">1</span></a>, <a class="reference internal" href="#tutorial-3-citations"><span class="std std-ref">2</span></a>] .</p>
<p>There’s also a prepared control dictionary, <em>cylinder_fwh.py</em>. This is identical to tutorials 3’s <em>cylinder.py</em> apart from the output section, which is detailed below.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;write output&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">&quot;format&quot;</span><span class="p">:</span> <span class="s2">&quot;vtk&quot;</span><span class="p">,</span>
    <span class="s2">&quot;surface variables&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;V&quot;</span><span class="p">,</span> <span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;rho&quot;</span><span class="p">,</span> <span class="s2">&quot;cp&quot;</span><span class="p">],</span>
    <span class="s2">&quot;volume variables&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;V&quot;</span><span class="p">,</span> <span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;rho&quot;</span><span class="p">,</span> <span class="s2">&quot;m&quot;</span><span class="p">,</span> <span class="s2">&quot;cp&quot;</span><span class="p">],</span>
    <span class="s2">&quot;fwh interpolate&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;fwh_surface1.stl&quot;</span><span class="p">],</span>
    <span class="s2">&quot;frequency&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;fwh interpolate&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;volume data&quot;</span><span class="p">:</span> <span class="mi">1000</span><span class="p">,</span>
        <span class="s2">&quot;surface data&quot;</span><span class="p">:</span> <span class="mi">1000</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">},</span>
</pre></div>
</div>
<p>In this case, we have chosen to output <em>fwh interpolate</em> data every single timestep, using the <em>fwh_surface1.stl</em> FWH surface definition file. Volume and surface data is much less frequent, since we already have all this data from when we ran <em>cylinder.py</em> <a class="reference internal" href="quick_start_3.html#tutorial-3"><span class="std std-ref">above</span></a>.</p>
<p>For the FWH tutorial we have also updated the <em>‘time marching’</em> section to run the simulation for 4 seconds, rather than 1.2. We run the CFD simulation in the normal way, using the command below.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>run_zcfd<span class="w"> </span>-m<span class="w"> </span>cylinder.h5<span class="w"> </span>-c<span class="w"> </span>cylinder_fwh.py
</pre></div>
</div>
<p>When we’ve run the CFD simulation of the cylinder, we should be able to see the FWH interpolated data in <em>‘cylinder_fwh_P1_OUTPUT/ACOUSTIC_DATA/fwh_surface1_FWHData.h5’</em>.</p>
</section>
<section id="fwh-observer-and-surface-motions">
<h2>FWH Observer and surface motions<a class="headerlink" href="#fwh-observer-and-surface-motions" title="Link to this heading">¶</a></h2>
<p>We’re going to use the FWH solver to calculate noise at two observer microphones - <em>‘Obs1’</em> and <em>‘Obs2’</em> (see <a class="reference internal" href="#qs3-fwhfig1"><span class="std std-ref">Fig 1</span></a>). <em>‘Obs1’</em> is an observer that is a fixed distance away from the cylinder - if we consider the cylinder in a wind tunnel, we could consider <em>‘Obs1’</em> as a microphone attached to the wind tunnel wall. <em>‘Obs2’</em> is different, and actually flies through the air at the same speed as the freestream air.</p>
<figure class="align-default" id="id1">
<span id="qs3-fwhfig1"></span><a class="reference internal image-reference" href="../_images/fwhdiagram_cyl1.svg"><img alt="FWH Observer and surface motions - CFD frame of reference" src="../_images/fwhdiagram_cyl1.svg" style="width: 600px;" />
</a>
<figcaption>
<p><span class="caption-text">FWH Observer and surface motions - CFD frame of reference</span><a class="headerlink" href="#id1" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>When the FWH equations are derived, we make an important assumption - that of a ‘quiescent medium’ (i.e. still air, with a free-stream velocity of zero). Clearly, with a freestream velocity of <em>(0,66.8,0)</em>, the flow in our CFD simulation does not satisfy this condition. In order to use the FWH solver, we therefore have to perform a co-ordinate transformation, as in <a class="reference internal" href="#qs3-fwhfig2"><span class="std std-ref">Fig 2</span></a>. In this ‘quiescent medium’ co-ordinate system, the cylinder and <em>‘Obs1’</em> are ‘flying’ through the air. In this co-ordinate system, we can also see that <em>‘Obs2’</em> represents a microphone fixed to the ground, as the cylinder flies overhead.</p>
<figure class="align-default" id="id2">
<span id="qs3-fwhfig2"></span><a class="reference internal image-reference" href="../_images/fwhdiagram_cyl2.svg"><img alt="FWH Observer and surface motions - FWH (quiescent medium) frame of reference" src="../_images/fwhdiagram_cyl2.svg" style="width: 600px;" />
</a>
<figcaption>
<p><span class="caption-text">FWH Observer and surface motions - FWH (quiescent medium) frame of reference</span><a class="headerlink" href="#id2" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="setting-up-the-fwh-solver-inputs">
<h2>Setting up the FWH solver inputs<a class="headerlink" href="#setting-up-the-fwh-solver-inputs" title="Link to this heading">¶</a></h2>
<p>Now that we know the motions of our observers and surface, we can run the FWH solver. The python code required to run the FWH solver is in the file <em>‘run_fwh_solver.py</em>’, and also written out below. We define the surfaces, observers and the solver settings, then use <code class="code docutils literal notranslate"><span class="pre">fwh.solve()</span></code> to actually run the FWH solver.</p>
<div class="highlight-python notranslate" id="qs3-fwh-run-code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">solvers</span> <span class="kn">import</span> <span class="n">fwh</span><span class="p">,</span> <span class="n">motion</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="c1"># FWH surface motion</span>
<span class="n">c</span>  <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.4</span> <span class="o">*</span> <span class="mf">277.7777</span> <span class="o">*</span> <span class="mi">287</span><span class="p">)</span>
<span class="n">v_surf</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span> <span class="mf">0.2</span> <span class="o">*</span> <span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="c1"># = [0,-66.8,0]</span>
<span class="n">t0</span> <span class="o">=</span> <span class="mf">0.002</span> <span class="c1">#t at first FWH data output</span>
<span class="n">surfaceCentrePoint</span> <span class="o">=</span> <span class="n">motion</span><span class="o">.</span><span class="n">ConstantVelocityPoint</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="n">v_surf</span><span class="p">)</span>
<span class="n">surfaceMotion</span> <span class="o">=</span> <span class="n">motion</span><span class="o">.</span><span class="n">NonrotatingSurface</span><span class="p">(</span><span class="n">surfaceCentrePoint</span><span class="p">)</span>

<span class="c1"># obs1 motion - [0,0,20] above cylinder centre</span>
<span class="n">obs1_CFD_frame_posn</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.25</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">20</span><span class="p">]</span>
<span class="n">obs1_0time_posn</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
  <span class="n">obs1_0time_posn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">obs1_CFD_frame_posn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">t0</span> <span class="o">*</span> <span class="n">v_surf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span>
<span class="n">obs1Motion</span> <span class="o">=</span> <span class="n">motion</span><span class="o">.</span><span class="n">ConstantVelocityPoint</span><span class="p">(</span><span class="n">obs1_0time_posn</span><span class="p">,</span> <span class="n">v_surf</span><span class="p">)</span>

<span class="c1"># obs2 motion - stationary, intersects with obs1 at t=2.5</span>
<span class="n">obs2_posn</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
  <span class="n">obs2_posn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">obs1_0time_posn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mf">2.5</span><span class="o">*</span> <span class="n">v_surf</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="n">obs2Motion</span> <span class="o">=</span> <span class="n">motion</span><span class="o">.</span><span class="n">StationaryPoint</span><span class="p">(</span><span class="n">obs2_posn</span><span class="p">)</span>

<span class="n">solverSettings</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;c&quot;</span><span class="p">:</span> <span class="n">c</span><span class="p">,</span>
    <span class="s2">&quot;dt&quot;</span><span class="p">:</span> <span class="mf">0.002</span><span class="p">,</span>
    <span class="s2">&quot;rho0&quot;</span><span class="p">:</span> <span class="mf">101325.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">277.7777</span> <span class="o">*</span> <span class="mi">287</span><span class="p">),</span>
    <span class="s2">&quot;p0&quot;</span><span class="p">:</span> <span class="mf">101325.0</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">surfaces</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;surf1&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;motion&quot;</span><span class="p">:</span> <span class="n">surfaceMotion</span><span class="p">,</span>
        <span class="s2">&quot;fileName&quot;</span><span class="p">:</span> <span class="s2">&quot;./cylinder_fwh_P1_OUTPUT/ACOUSTIC_DATA/fwh_surface1_FWHData.h5&quot;</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">observers</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Obs1&quot;</span><span class="p">:</span> <span class="n">obs1Motion</span><span class="p">,</span> <span class="s2">&quot;Obs2&quot;</span><span class="p">:</span> <span class="n">obs2Motion</span><span class="p">}</span>

<span class="n">pOut</span><span class="p">,</span> <span class="n">tOut</span> <span class="o">=</span> <span class="n">fwh</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">surfaces</span><span class="p">,</span> <span class="n">observers</span><span class="p">,</span> <span class="n">solverSettings</span><span class="p">)</span>

<span class="n">dataForJson</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;p&quot;</span><span class="p">:</span> <span class="n">pOut</span><span class="p">,</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span> <span class="n">tOut</span><span class="p">}</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;./FWH_data.json&quot;</span><span class="p">,</span><span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">dataForJson</span><span class="p">,</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>More details on FWH solver setup can be found <a class="reference internal" href="../fwh.html#fwhrunning"><span class="std std-ref">here</span></a>, but the most important concept is that we use <em>‘motion classes’</em> to define observer and surface motions.
The available <a class="reference internal" href="../fwh.html#fwhobsmotions"><span class="std std-ref">observer motions</span></a> are <em>‘OriginPoint’</em>, <em>‘StationaryPoint’</em> and <em>‘ConstantVelocityPoint’</em>. The available <a class="reference internal" href="../fwh.html#fwhsurfmotions"><span class="std std-ref">surface motions</span></a> (which rely on an <a class="reference internal" href="../fwh.html#fwhobsmotions"><span class="std std-ref">observer motion</span></a> to define the motion of their centre) are <em>‘NonrotatingSurface’</em> and <em>‘RotatingSurface’</em>.</p>
<p>The velocities and fluid properties used in the FWH simulation are taken from the <em>‘cylinder.py’</em> zCFD control file. <code class="code docutils literal notranslate"><span class="pre">solverSettings['dt']</span></code> has been set to be the same as the timestep between outputs in the FWH surface data (0.002 seconds, see <a class="reference internal" href="quick_start_3.html#quick-start-3-output"><span class="std std-ref">above</span></a>).</p>
<p>In general, we can consider the motion of a point on an FWH surface to be defined by <span class="math notranslate nohighlight">\(\mathbf{x}(t)=\mathbf{x}_0+ \mathbf{V}_{surf} (t-t_0)\)</span> in the FWH co-ordinate frame.
<span class="math notranslate nohighlight">\(\mathbf{V}_{surf}\)</span> is defined by the user in the <a class="reference internal" href="../fwh.html#fwhsurfmotions"><span class="std std-ref">surface motion class</span></a> (called <em>surfaceMotion</em> above), <span class="math notranslate nohighlight">\(\mathbf{x}_0\)</span> is the position defined by the FWH surface definition file (<em>‘fwh_surface1.stl’</em>, see <a class="reference internal" href="#qs3-stl-pic"><span class="std std-ref">above</span></a>), and <span class="math notranslate nohighlight">\(t_0\)</span> is the simulation time at which the solver first outputted the FWH data. In our case, <span class="math notranslate nohighlight">\(t_0\)</span> = 0.002 seconds (see <a class="reference internal" href="quick_start_3.html#quick-start-3-output"><span class="std std-ref">Output</span></a>).</p>
<p>The centre of the cylinder in the CFD mesh is at (0.25,0,0), and we want <em>Obs1</em> to always be (0,0,20) metres  away from the cylinder centre during the FWH simulation.
Since the cylinder ‘travels with’ the FWH surface (see <a class="reference internal" href="#qs3-fwhfig2"><span class="std std-ref">Fig. 2</span></a>), we can therefore say that the motion of the cylinder centre in the FWH co-ordinate frame is <span class="math notranslate nohighlight">\(\mathbf{x}(t)=(0.25,0,0) + \mathbf{V}_{surf} (t-t_0) = \left( (0.25,0,0) - 0.002 \ \mathbf{V}_{surf} \right) + \mathbf{V}_{surf} t\)</span>.
We therefore set the motion of <em>Obs1</em> to be <span class="math notranslate nohighlight">\(\mathbf{x}(t)= \left( (0.25,0,20) - 0.002 \  \mathbf{V}_{surf} \right) + \mathbf{V}_{surf} t\)</span>.
We set <em>Obs2</em> to be stationary in the FWH reference frame, and to be coincident with <em>Obs1</em> at <em>t=2.5</em>. We save the outputs to a json file called <em>FWH_data.json</em>.</p>
</section>
<section id="running-the-fwh-solver">
<h2>Running the FWH solver<a class="headerlink" href="#running-the-fwh-solver" title="Link to this heading">¶</a></h2>
<p>The python code above is replicated in <em>‘run_fwh_solver.py</em>’. To run the FWH solver, we simply run the command below from within the <a class="reference internal" href="../running/execution.html#zcfd-command"><span class="std std-ref">zCFD command-line environment</span></a>. You may need to change the <code class="code docutils literal notranslate"><span class="pre">surfaces[&quot;surf1&quot;][&quot;fileName&quot;]</span></code> parameter depending on how many ranks you used in your zCFD run.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>python3<span class="w"> </span>run_fwh_solver.py
</pre></div>
</div>
<p>This will output various information to the screen, including the ‘valid min and max times’ for each surface / observer combination.</p>
<p>The valid min and max times denote the time window during which an observer receives data from all points on the FWH surface.
A pressure signal emitted from a point on the FWH surface at time <em>t</em> takes <em>r/c</em> seconds to arrive at an observer, where <em>r</em> is the distance from the surface point to observer and <em>c</em> is the speed of sound.
Therefore the valid observer time window will always be later than the FWH surface output time window (in our case, 0.002:1.2 seconds) due to the distance from the FWH surface to the observer.
The valid observer time window will be narrower if the FWH surface is large, since the larger the surface the larger the time delay between signals from different points on the surface reaching the observer becomes.</p>
</section>
<section id="post-processing">
<h2>Post-processing<a class="headerlink" href="#post-processing" title="Link to this heading">¶</a></h2>
<p>The <a class="reference internal" href="quick_start_1.html#qs1-jupyter"><span class="std std-ref">jupyter notebook</span></a> <em>postprocess_fwh_data.ipynb</em> from the zip file can be used to post-process the FWH data.</p>
<p><em>Obs1</em> moves through the FWH medium at a constant displacement from the cylinder centre (see <a class="reference internal" href="#qs3-fwhfig2"><span class="std std-ref">Fig 1</span></a>). We see from our post-processing that the noise experienced by <em>Obs1</em> is dominated by a constant 10 Hz component, which is the shedding frequency of the cylinder. Various harmonics of the 10 Hz signal are present in the power spectral density plot for <em>Obs1</em>.</p>
<a class="reference internal image-reference" href="../_images/Obs1_p.svg"><img alt="Obs1 p(t)" src="../_images/Obs1_p.svg" style="width: 600px;" />
</a>
<a class="reference internal image-reference" href="../_images/Obs1_psd.svg"><img alt="Obs1 PSD" src="../_images/Obs1_psd.svg" style="width: 600px;" />
</a>
<p>During the FWH simulation, the cylinder gets closer to <em>Obs2</em> from 0 to 2.5 seconds, before getting further away from <em>Obs2</em> from 2.5 seconds onwards. We can see in the <em>Obs2</em> <em>p(t)</em> plot that the peaks are closer together from 0 to 2.5 seconds than they are after 2.5 seconds. This is due to Doppler shift. We can also see the effect of Doppler shift in the power spectral density, which has a more rounded 10 Hz peak than that seen in <em>Obs1</em>.</p>
<a class="reference internal image-reference" href="../_images/Obs2_p.svg"><img alt="Obs2 p(t)" src="../_images/Obs2_p.svg" style="width: 600px;" />
</a>
<a class="reference internal image-reference" href="../_images/Obs2_psd.svg"><img alt="Obs2 PSD" src="../_images/Obs2_psd.svg" style="width: 600px;" />
</a>
<p><em>postprocess_fwh_data.ipynb</em> also creates <em>.wav</em> files, which allow you to listen to the sound experienced by <em>Obs1</em> and <em>Obs2</em>.</p>
</section>
<section id="extensions">
<h2>Extensions<a class="headerlink" href="#extensions" title="Link to this heading">¶</a></h2>
<p>To become more comfortable with the FWH solver, various extensions to this exercise are possible. Here are some suggestions.</p>
<ol class="arabic simple">
<li><p>Re-run the zCFD solver, but this time also extract FWH data on the cylinder <a class="reference internal" href="../reference_guide/write_output.html#write-output"><span class="std std-ref">wall</span></a>. Run the FWH solver (using the wall data as an <a class="reference internal" href="../fwh.html#fwhhowworks"><span class="std std-ref">impermeable</span></a> FWH surface) and compare the results to those achieved using the <em>fwh_surface1</em> permeable FWH surface.</p></li>
<li><p>Re-run the zCFD solver, but this time also extract FWH data on the <em>fwh_surface2.stl</em> and <em>fwh_surface3.stl</em> surfaces. These are like <em>fwh_surface1.stl</em> but slightly larger. Run the FWH solver with these surfaces and investigate the effect of using different surfaces on the FWH results.</p></li>
<li><p>Add extra observers of your choice to the FWH solver.</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Since the cylinder CFD simulation is ‘2.5D’ (i.e. the mesh only has a single cell in the <em>x</em> direction), the distance scaling of <em>p(t)</em> at observers will be non-physical.</p>
</div>
</section>
<section id="citations">
<span id="tutorial-3-citations"></span><h2>Citations<a class="headerlink" href="#citations" title="Link to this heading">¶</a></h2>
<ol class="arabic simple">
<li><p>Mitchell, B., Lele, S., &amp; Moin, P. (1999). Direct computation of the sound generated by vortex pairing in an axisymmetric jet. Journal of Fluid Mechanics, 383, 113-142. 10.1017/S0022112099003869</p></li>
<li><p>Ricciardi, T. R. , Wolf W. R, &amp; Spalart P. R. (2022). On the Application of Incomplete Ffowcs Williams and Hawkings Surfaces for Aeroacoustic Predictions. AIAA Journal, 60:3, 1971-1977. 10.2514/1.J061285</p></li>
</ol>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/ZCFD_Mark_CMYK.png" alt="Logo of zCFD User Guide"/>
            </a></p><h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../running/intro.html">Running zCFD</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="intro.html">Getting Started</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="quick_start_1.html">Tutorial 1: Simple Aerofoil</a></li>
<li class="toctree-l2"><a class="reference internal" href="quick_start_2.html">Tutorial 2: Steady State RANS</a></li>
<li class="toctree-l2"><a class="reference internal" href="quick_start_3.html">Tutorial 3: Time accurate solution</a></li>
<li class="toctree-l2"><a class="reference internal" href="quick_start_4.html">Tutorial 4: Aero-acoustics</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Tutorial 3a: FWH Solver</a></li>
<li class="toctree-l2"><a class="reference internal" href="epic_tutorial.html">Running zCFD using EPIC</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../reference_guide/intro.html">Reference Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../functions.html">zCFD Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../meshutil.html">Mesh Conversion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fwh.html">FWH solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zm3.html">zM3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../visualisation.html">Visualisation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../utilities.html">Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../troubleshooting.html">Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pdf.html">PDF copy</a></li>
</ul>


<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2016-23, Zenotech Ltd.
      
      |
      <a href="../_sources/getting_started/fwh_tutorial.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
    <script>

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-32675146-1']);
      _gaq.push(['_setDomainName', 'none']);
      _gaq.push(['_setAllowLinker', true]);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'https://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
    
  </body>
</html>